---
# ğŸ§© Playbook: run-script.yaml
# ğŸ“˜ Description:
# This playbook connects to one or more remote machines and executes a shell
# script located at a user-specified path. The `become` (sudo) behavior is
# controlled dynamically by a variable, allowing the same playbook to be used
# for both privileged and non-privileged scripts.
#
# ğŸ§  Ideal for:
# - Executing arbitrary maintenance or setup scripts remotely
# - Controlling privilege escalation dynamically
# - Receiving Telegram alerts for success or failure
#
# ğŸ§° Requirements:
# - community.general collection (install with `ansible-galaxy collection install community.general`)
# - Telegram bot token and chat ID set in Semaphore or inventory
#
# ğŸ§© Variables:
#   target_group:          â†’ Target host(s) or inventory group
#   script_path:       â†’ Full path to the .sh script on the remote host (e.g. /home/ubuntu/Scripts/update.sh)
#   use_become:        â†’ Whether to use sudo (true/false)
#   telegram_token:    â†’ Telegram bot token from BotFather
#   telegram_chat_id:  â†’ Telegram chat ID (user or group)
#
# ğŸ§ª Example Variables:
#   target_group: ["192.168.108.101"]
#   script_path: "/home/ubuntu/Scripts/backup.sh"
#   use_become: true
#   telegram_token: "123456789:ABCdefGhIjKlmNoPqRsTuVwxyz"
#   telegram_chat_id: "123456789"
#
# âœ… Result:
# - The script executes remotely (with or without sudo)
# - Output and errors are logged
# - Telegram message sent on success or failure
# ğŸ§  Example usage:
#  ansible-playbook -i inventory.ini ./common/run-script.yaml -e "target_group=UbuntuServers"




- name: Run remote shell script and send Telegram notification
  hosts: "{{ target_group | d([]) }}"
  become: "{{ use_become | default(false) }}"
  vars:
    script_path: "{{ script_path }}"
    telegram_bot_token: "{{ lookup('env', 'TELEGRAM_BOT_TOKEN') }}"
    telegram_chat_id: "{{ lookup('env', 'TELEGRAM_CHAT_ID') }}"

  tasks:
    # ğŸ” Step 1: Verify that the script exists
    - name: Check if the script exists on remote host
      ansible.builtin.stat:
        path: "{{ script_path }}"
      register: script_status

    # ğŸš« Step 2: Stop if the script is missing
    - name: Fail if script not found
      ansible.builtin.fail:
        msg: "Script not found at {{ script_path }}"
      when: not script_status.stat.exists

    # â–¶ï¸ Step 3: Execute the script
    - name: Run the script
      ansible.builtin.shell: "bash {{ script_path }}"
      args:
        chdir: "{{ script_path | dirname }}"
      register: script_output
      changed_when: true

    # ğŸŸ¢ Step 4: Send Telegram notification (success)
    - name: Send Telegram notification (success)
      community.general.telegram:
        token: "{{ telegram_bot_token }}"
        chat_id: "{{ telegram_chat_id }}"
        msg: |
          âœ… *Script executed successfully on {{ inventory_hostname }}*
          ğŸ“œ Path: `{{ script_path }}`
          ğŸ•’ Time: {{ ansible_date_time.iso8601 }}
          ---
          {{ script_output.stdout | default('No output') }}
        parse_mode: markdown
      when: script_output.rc == 0

    # ğŸ”´ Step 5: Send Telegram notification (failure)
    - name: Send Telegram notification (failure)
      community.general.telegram:
        token: "{{ telegram_bot_token }}"
        chat_id: "{{ telegram_chat_id }}"
        msg: |
          âŒ *Script execution FAILED on {{ inventory_hostname }}*
          ğŸ“œ Path: `{{ script_path }}`
          ğŸ•’ Time: {{ ansible_date_time.iso8601 }}
          ---
          {{ script_output.stderr | default('No error output') }}
        parse_mode: markdown
      when: script_output.rc != 0
