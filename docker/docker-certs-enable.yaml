---
# ğŸ§© Playbook: docker-certs-enable.yaml
# ğŸ“˜ Description:
# Configures the Docker daemon to use TLS certificates for secure remote access.
# This playbook modifies the systemd Docker service configuration to enable
# authenticated and encrypted connections over TCP port 2376 using the certificates
# generated by the `docker_certs.yml` playbook.
#
# ğŸ”§ Notes:
# - Assumes Docker certificates are already created under `/root/docker-certs`
#   (or the path defined by `certs_path`).
# - Automatically detects the host's primary IP address and binds Docker's remote
#   API endpoint to `tcp://<ip>:2376`.
# - Enables TLS verification with `--tlsverify`, using the CA, server, and key
#   files generated previously.
# - Reloads the systemd daemon and restarts Docker to apply the changes.
# - Once complete, the Docker daemon will listen on both:
#     - Unix socket (`/var/run/docker.sock`)
#     - TCP socket (`<ip>:2376`) secured with TLS
#
# âš™ï¸ Requirements:
# - Docker must already be installed on the target host.
# - Certificates must exist in `{{ certs_path }}` (generated by `docker_certs.yml`).
# - Requires sudo/root privileges.
#
# ğŸ§  Example usage:
# ansible-playbook -i inventory.ini ./docker/docker-certs-enable.yaml -e "target_group=DockerServers"
#
# ğŸ§© Example client connection:
# docker --tlsverify \
#   --tlscacert=ca.pem \
#   --tlscert=cert.pem \
#   --tlskey=key.pem \
#   -H=tcp://<host-ip>:2376 info
#
# ğŸ”’ Security Recommendations:
# - Limit TCP port 2376 access to trusted IPs via firewall or security groups.
# - Use `ufw`, `iptables`, or your hypervisorâ€™s firewall to restrict access.
# - Consider running Docker behind a VPN or SSH tunnel for an additional layer of security.

- name: "Docker Certs enable"
  hosts: "{{ target_group | d('all') }}"
  become: true

  vars:
    certs_path: "/root/docker-certs"

  tasks:
    - name: Check if docker certs are existing
      ansible.builtin.stat:
        path: "{{ certs_path }}"
      register: certs_dir

    - name: Fail if docker certs are not existing
      ansible.builtin.fail:
        msg: "Docker certificates are not existing in {{ certs_path }}."
      when: not certs_dir.stat.exists

    - name: Get machine's primary internal IP address from eth0
      ansible.builtin.setup:
      register: ip_address

    - name: Set machine's primary internal IP address
      ansible.builtin.set_fact:
        ip_address: "{{ ip_address.ansible_facts.ansible_default_ipv4.address }}"

    - name: Validate IP address format
      ansible.builtin.assert:
        that:
          - ip_address is match('^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$')
        fail_msg: "ip_address is not a valid IP address."
        success_msg: "ip_address is a valid IP address."

    - name: Configure Docker daemon to use TLS certificates
      ansible.builtin.lineinfile:
        path: /lib/systemd/system/docker.service
        regexp: '^ExecStart='
        line: >
          ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
          -H tcp://{{ ip_address }}:2376 --tlsverify
          --tlscacert={{ certs_path }}/ca.pem
          --tlscert={{ certs_path }}/server-cert.pem
          --tlskey={{ certs_path }}/server-key.pem
        state: present

    - name: Reload systemd daemon
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Restart Docker daemon with TLS configuration
      ansible.builtin.systemd:
        name: docker
        state: restarted
        enabled: true
